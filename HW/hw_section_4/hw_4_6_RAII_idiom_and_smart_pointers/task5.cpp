/*
Представим арифметическое выражение, содержащее числовые константы и операции сложения и умножения, 
в виде дерева. В листьях этого дерева будут находиться константы, 
а в промежуточных узлах — операции. Вам дан абстрактный базовый класс Expression, 
представляющий из себя такое дерево. Вам надо унаследовать от него классы-наследники 
для констант, операции сложения и операции умножения так, чтобы приведённый в функции 
main код (и аналогичные примеры) заработали.

Функции базового класса Evaluate и ToString должны переопределяться в классах-наследниках. 
Evaluate должна вычислять выражение, а ToString возвращать его текстовую запись (как в примере). 
При умножении на сумму запись суммы должна браться в скобки. Никаких особых специальных правил 
оформления нулевых или единичных множителей писать не нужно.

Кроме классов-наследников, Вам надо будет определить функции Const, Sum и Product, которые 
используются в функции main в примере. Лишних копирований дерева быть не должно: 
мы будем проверять, что создано ровно столько экземпляров классов, сколько требуется 
для построения дерева. Разумеется, утечек памяти тоже не должно быть.

Для преобразования чисел в строки используете функцию std::to_string.
*/
#include <iostream>
#include <memory>
#include <string>

class Expression {
public:
    virtual int Evaluate() const = 0;
    virtual std::string ToString() const = 0;
    virtual ~Expression() {}
};
